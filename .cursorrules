# Cursor 工作指导书 - 企业微信托管平台智能回复服务

## 项目概述

这是一个基于 NestJS 的企业微信智能回复中间服务层。通过对接企业微信账号托管平台，调用其提供的消息收发、好友管理等 API 能力，结合 花卷agent Open API 实现企业微信群运营的智能化自动回复。

**核心定位：**
- **中间服务层**：连接托管平台和 AI 能力
- **消息回调处理**：接收托管平台的消息回调
- **AI 智能回复**：调用 花卷agent 生成回复
- **消息发送**：通过托管平台 API 发送回复给用户

**技术栈：**
- 框架：NestJS 10.3.0
- 语言：TypeScript 5.3.3
- 运行时：Node.js 20.x
- API 文档：Swagger
- 日志：Winston
- HTTP 客户端：Axios
- 测试：Jest

## 核心架构

### 模块结构

```
src/
├── core/                          # 核心基础模块
│   └── api-client/               # 统一 API 客户端服务
├── modules/business/             # 业务模块
│   ├── chat/                     # 会话管理模块
│   └── message-sender/           # 消息发送模块
├── third-party/                  # 第三方集成
│   └── agent-api/                # Agent API 集成
├── app.module.ts                 # 应用根模块
└── main.ts                       # 应用入口
```

### 关键服务职责

1. **api-client.service.ts** - 统一的 HTTP 客户端封装
   - 封装 GET/POST 请求方法
   - 统一错误处理
   - 日志记录

2. **agent-api.service.ts** - AI Agent API 调用服务
   - 调用 花卷agent Open API
   - 会话上下文管理
   - 支持流式和非流式回复

3. **chat.service.ts** - 会话管理服务
   - 获取会话列表
   - 拉取聊天历史
   - 调用托管平台 API

4. **message-sender.service.ts** - 消息发送服务
   - 单发消息
   - 群发消息
   - 调用托管平台发送 API

5. **conversation.manager.ts** - 会话上下文管理器
   - 管理多轮对话上下文
   - 会话历史记录
   - 会话超时控制

## 业务流程

### 消息处理完整流程

```
1. 托管平台收到企业微信消息
         ↓
2. 托管平台回调本服务 POST /message 接口
         ↓
3. 解析消息内容（fromUser, content, isRoom等）
         ↓
4. 生成会话 ID（user_wxid 或 room_roomid）
         ↓
5. 调用 AgentApiService.chat() 生成 AI 回复
   └─> POST https://api.wolian.cc/api/v1/chat
         ↓
6. 获取 AI 回复内容
         ↓
7. 调用 MessageSenderService.sendMessage()
   └─> POST https://stride-bg.dpclouds.com/stream-api/message/send
         ↓
8. 回复发送成功，记录日志
```

## 重要 API 文档

在开发过程中，涉及第三方 API 调用时，务必仔细阅读以下文档：

### 1. 托管平台 API 文档
- **企业级 API**：https://s.apifox.cn/34adc635-40ac-4161-8abb-8cd1eea9f445
- **小组级 API**：https://s.apifox.cn/acec6592-fec1-443b-8563-10c4a10e64c4

**主要接口：**
- 获取会话列表：`GET /stream-api/chat/list`
- 获取聊天历史：`GET /stream-api/message/history`
- 发送消息：`POST /stream-api/message/send`
- 消息回调格式：查看文档中的回调章节

### 2. Agent API 文档
- **官方文档**：https://docs.wolian.cc/

**主要接口：**
- 聊天接口：`POST /api/v1/chat`
- 获取模型列表：`GET /api/v1/models`
- 获取工具列表：`GET /api/v1/tools`

### 3. NestJS 官方文档
- **官方文档**：https://docs.nestjs.com/

**重要章节：**
- 模块（Modules）
- 控制器（Controllers）
- 提供者（Providers）
- 依赖注入（Dependency Injection）
- 中间件（Middleware）

## 代码规范

### TypeScript 规范

1. **严格类型检查**
   - 启用 TypeScript strict 模式
   - 避免使用 `any`，使用 `unknown` 或具体类型
   - 为函数参数和返回值明确指定类型

2. **命名规范**
   - 文件名：kebab-case（如 `agent-api.service.ts`）
   - 类名：PascalCase（如 `AgentApiService`）
   - 接口名：PascalCase，接口以 `I` 开头（如 `IAgentProfile`）
   - 变量/函数：camelCase（如 `sendMessage`）
   - 常量：UPPER_SNAKE_CASE（如 `API_TIMEOUT`）

3. **文件组织**
   ```typescript
   // 1. 导入区块（按类型分组）
   import { Injectable } from '@nestjs/common';
   import { ConfigService } from '@nestjs/config';
   import axios from 'axios';

   // 2. 接口/类型定义
   interface MessageData {
     content: string;
     type: string;
   }

   // 3. 装饰器和类定义
   @Injectable()
   export class ExampleService {
     private readonly logger = new Logger(ExampleService.name);

     constructor(private readonly configService: ConfigService) {}

     // 公共方法
     async publicMethod() {}

     // 私有方法
     private privateMethod() {}
   }
   ```

### NestJS 最佳实践

1. **依赖注入**
   - 优先使用构造函数注入
   - 使用 `@Injectable()` 装饰器标记所有服务
   - 在 module 的 `providers` 中注册服务

2. **模块设计**
   - 每个功能模块包含：module.ts, service.ts, controller.ts
   - 使用 DTO（Data Transfer Object）验证输入
   - 使用 `class-validator` 和 `class-transformer` 进行验证

3. **异常处理**
   ```typescript
   import { HttpException, HttpStatus } from '@nestjs/common';

   throw new HttpException('错误信息', HttpStatus.BAD_REQUEST);
   ```

4. **日志记录**
   ```typescript
   import { Logger } from '@nestjs/common';

   private readonly logger = new Logger(ServiceName.name);

   this.logger.log('正常日志');
   this.logger.error('错误日志', error.stack);
   this.logger.warn('警告日志');
   this.logger.debug('调试日志');
   ```

## 开发工作流

### 添加新功能

1. **确定功能模块归属**
   - 核心功能 → `src/core/`
   - 业务功能 → `src/modules/business/`
   - 第三方集成 → `src/third-party/`

2. **创建 DTO**
   ```typescript
   import { IsString, IsNotEmpty, IsNumber } from 'class-validator';
   import { ApiProperty } from '@nestjs/swagger';

   export class CreateMessageDto {
     @ApiProperty({ description: '消息内容' })
     @IsString()
     @IsNotEmpty()
     content: string;

     @ApiProperty({ description: '消息类型', example: 1 })
     @IsNumber()
     msgType: number;
   }
   ```

3. **实现 Service**
   ```typescript
   @Injectable()
   export class MessageService {
     private readonly logger = new Logger(MessageService.name);

     constructor(
       private readonly apiClientService: ApiClientService,
     ) {}

     async sendMessage(data: SendMessageDto) {
       try {
         const result = await this.apiClientService.callPostApi(
           'https://api.example.com/send',
           data
         );
         this.logger.log('发送消息成功');
         return result;
       } catch (error) {
         this.logger.error('发送消息失败', error.stack);
         throw error;
       }
     }
   }
   ```

4. **实现 Controller**
   ```typescript
   @Controller('api/v1/messages')
   @ApiTags('消息管理')
   export class MessageController {
     constructor(private readonly messageService: MessageService) {}

     @Post('send')
     @ApiOperation({ summary: '发送消息' })
     @ApiResponse({ status: 200, description: '发送成功' })
     async sendMessage(@Body() dto: SendMessageDto) {
       return this.messageService.sendMessage(dto);
     }
   }
   ```

5. **注册到 Module**
   ```typescript
   @Module({
     imports: [ApiClientModule],
     controllers: [MessageController],
     providers: [MessageService],
     exports: [MessageService], // 如果其他模块需要使用
   })
   export class MessageModule {}
   ```

6. **在根模块中导入**
   ```typescript
   // app.module.ts
   @Module({
     imports: [
       ConfigModule.forRoot(),
       MessageModule,
       // ... 其他模块
     ],
   })
   export class AppModule {}
   ```

### 环境配置

1. **配置管理**
   - 所有配置放在 `.env` 文件
   - 使用 `@nestjs/config` 的 `ConfigService` 读取

2. **配置访问示例**
   ```typescript
   constructor(private readonly configService: ConfigService) {
     const apiKey = this.configService.get<string>('AGENT_API_KEY');
     const timeout = this.configService.get<number>('API_TIMEOUT', 30000);
   }
   ```

## API 开发规范

### RESTful API 设计

1. **路由命名**
   - 使用名词复数形式：`/api/v1/messages`
   - 避免动词：❌ `/api/v1/sendMessage` ✅ `/api/v1/messages`

2. **HTTP 方法**
   - GET：查询资源
   - POST：创建资源
   - PUT/PATCH：更新资源
   - DELETE：删除资源

3. **统一响应格式（重要！）**

   **全局策略：所有 HTTP 响应自动统一包装（main.ts 中已全局注册）**

   **成功响应：**
   ```typescript
   {
     "success": true,
     "data": { /* 业务数据 */ },
     "message": "操作成功",  // 可选
     "timestamp": "2024-10-24T12:00:00.000Z"
   }
   ```

   **错误响应：**
   ```typescript
   {
     "success": false,
     "error": {
       "code": "BAD_REQUEST",
       "message": "错误描述",
       "details": { /* 错误详情 */ }  // 可选
     },
     "timestamp": "2024-10-24T12:00:00.000Z",
     "path": "/api/v1/resource"  // 可选
   }
   ```

   **Controller 开发规范：**
   ```typescript
   // ✅ 推荐：直接返回业务数据，拦截器自动包装
   @Get('list')
   async getList() {
     const data = await this.service.getList();
     return data;  // 自动包装为 { success: true, data: {...}, timestamp: '...' }
   }

   // ✅ 推荐：抛出异常，过滤器自动处理
   @Post('create')
   async create(@Body() dto: CreateDto) {
     if (!dto.name) {
       throw new BadRequestException('名称不能为空');
       // 自动转换为: { success: false, error: { code: 'BAD_REQUEST', ... } }
     }
     return await this.service.create(dto);
   }

   // ⚠️ 特殊场景：需要返回原始格式（第三方回调、透传第三方 API）
   import { RawResponse } from '@core/response';

   @RawResponse()  // 明确标记：豁免统一包装
   @Post('callback')
   async handleCallback(@Body() body: any) {
     await this.service.handle(body);
     return { errcode: 0, errmsg: 'ok' };  // 返回第三方要求的原始格式
   }
   ```

   **何时使用 @RawResponse：**
   1. **第三方回调接口** - 企微、支付等回调必须返回特定格式
   2. **透传第三方 API** - 直接返回第三方 API 原始响应
   3. **特殊协议接口** - 需要特定响应格式的协议

   **示例对比：**
   ```typescript
   // 业务接口（使用统一格式）
   @Controller('bot')
   export class BotController {
     @Get('list')
     async getBotList() {
       return await this.botService.getList();
       // 响应: { success: true, data: [...], timestamp: '...' }
     }
   }

   // 企微回调（使用原始格式）
   @Controller('message')
   export class MessageController {
     @RawResponse()  // 必须添加
     @Post()
     async receiveMessage(@Body() body: any) {
       await this.messageService.handle(body);
       return { errcode: 0, errmsg: 'ok' };  // 企微要求的格式
     }
   }
   ```

### Swagger 文档

```typescript
@ApiTags('功能模块')
@Controller('api/v1/resource')
export class ResourceController {
  @Post()
  @ApiOperation({ summary: '创建资源' })
  @ApiResponse({ status: 201, description: '创建成功' })
  @ApiResponse({ status: 400, description: '请求参数错误' })
  async create(@Body() dto: CreateResourceDto) {
    // 实现
  }
}
```

## 测试指南

### 单元测试

```typescript
describe('MessageService', () => {
  let service: MessageService;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [MessageService],
    }).compile();

    service = module.get<MessageService>(MessageService);
  });

  it('should send message successfully', async () => {
    const result = await service.sendMessage({ content: 'test' });
    expect(result.success).toBe(true);
  });
});
```

### API 测试

使用 `api-test.http` 文件进行测试：

```http
### 健康检查
GET http://localhost:8080/agent/health

### 发送消息
POST http://localhost:8080/message-sender/send
Content-Type: application/json

{
  "token": "test-token",
  "content": "测试消息",
  "toWxid": "wxid_test",
  "msgType": 1
}
```

## 常见任务模板

### 调用托管平台 API

```typescript
@Injectable()
export class ChatService {
  constructor(private readonly apiClientService: ApiClientService) {}

  async getChatList(token: string, pageSize?: number) {
    const apiUrl = 'https://stride-bg.dpclouds.com/stream-api/chat/list';
    const params = { token, pageSize };

    return await this.apiClientService.callGetApi(apiUrl, params);
  }
}
```

### 调用 Agent API

```typescript
@Injectable()
export class AgentApiService {
  async chat(message: string, conversationId: string) {
    const apiUrl = `${this.baseURL}/chat`;

    const response = await axios.post(
      apiUrl,
      {
        model: this.defaultModel,
        messages: [{ role: 'user', content: message }],
        conversation_id: conversationId,
      },
      {
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
        },
      }
    );

    return response.data;
  }
}
```

## 调试技巧

### 查看日志

```bash
# 实时查看日志
tail -f logs/combined-$(date +%Y-%m-%d).log

# 查看错误日志
tail -f logs/error-$(date +%Y-%m-%d).log

# 过滤特定关键词
grep "AgentApiService" logs/combined-$(date +%Y-%m-%d).log
```

### 健康检查

```bash
# 检查 Agent API 连接
curl http://localhost:8080/agent/health

# 测试 AI 聊天
curl -X POST http://localhost:8080/agent/test-chat \
  -H "Content-Type: application/json" \
  -d '{"message": "你好", "conversationId": "test"}'
```

## 性能优化建议

1. **异步处理**
   - 使用 `async/await` 处理异步操作
   - 避免阻塞主线程

2. **错误处理**
   - 使用 try-catch 捕获异常
   - 记录详细错误日志
   - 实现重试机制

3. **API 调用优化**
   - 设置合理的超时时间
   - 使用连接池
   - 实现请求限流

## 安全注意事项

1. **敏感信息保护**
   - 不要在代码中硬编码密钥
   - 使用环境变量存储敏感配置
   - `.env` 文件不要提交到代码仓库（已在 .gitignore）

2. **输入验证**
   - 使用 DTO 和 class-validator 验证所有输入
   - 防止注入攻击

3. **错误信息**
   - 不要在错误响应中暴露敏感信息
   - 记录详细日志但返回通用错误信息

## 部署流程

### 构建生产版本

```bash
# 安装依赖
npm install

# 构建
npm run build

# 启动生产服务
npm run start:prod
```

### 使用 PM2 部署

```bash
# 安装 PM2
npm install -g pm2

# 启动服务
pm2 start dist/main.js --name duliday-wecom-service

# 设置开机自启
pm2 startup
pm2 save

# 查看日志
pm2 logs duliday-wecom-service
```

## 故障排查

### 常见问题

1. **Agent API 连接失败**
   - 检查 `AGENT_API_KEY` 是否有效
   - 验证 `AGENT_API_BASE_URL` 配置
   - 测试网络连接：`curl https://api.wolian.cc`

2. **托管平台 API 调用失败**
   - 检查 token 是否有效
   - 验证 API 地址是否正确
   - 查看托管平台 API 文档

3. **会话上下文丢失**
   - 检查 conversationId 生成逻辑
   - 验证会话管理器配置
   - 考虑使用 Redis 持久化

## 文档资源

- **项目文档**：[README.md](./README.md)
- **快速开始**：[QUICKSTART.md](./QUICKSTART.md)
- **托管平台 API**：https://s.apifox.cn/34adc635-40ac-4161-8abb-8cd1eea9f445
- **Agent API**：https://docs.wolian.cc/
- **NestJS 文档**：https://docs.nestjs.com/

## Git 工作流

### 提交规范

```bash
# 功能开发
git commit -m "feat: 添加消息群发功能"

# Bug 修复
git commit -m "fix: 修复会话超时问题"

# 文档更新
git commit -m "docs: 更新 API 文档"

# 代码重构
git commit -m "refactor: 重构消息处理逻辑"

# 性能优化
git commit -m "perf: 优化 API 调用性能"

# 测试相关
git commit -m "test: 添加消息服务单元测试"
```

## 代码审查清单

在提交代码前检查：

- [ ] 代码符合 TypeScript 规范
- [ ] 添加了必要的类型定义
- [ ] 实现了错误处理
- [ ] 添加了日志记录
- [ ] 更新了 API 文档（Swagger）
- [ ] 测试通过 `npm run test`
- [ ] 代码格式化 `npm run format`
- [ ] 代码检查 `npm run lint`
- [ ] 更新了相关文档

## 开发原则

1. **保持简单** - 优先选择简单明了的解决方案
2. **模块化** - 功能独立，职责单一
3. **可测试** - 编写可测试的代码
4. **可维护** - 代码清晰，文档完善
5. **性能优先** - 关注性能和用户体验
6. **安全第一** - 始终考虑安全因素

---

**最后更新：** 2025-10-14
**维护者：** DuLiDay Team
