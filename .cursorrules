# DuLiDay 企业微信智能回复服务 - 开发指南

## 项目概述

基于 NestJS 的企业微信智能回复中间服务层。连接托管平台和花卷 Agent，实现 AI 自动回复。

**技术栈**：NestJS 10.3 | TypeScript 5.3 | Node.js 20+ | Bull Queue | Redis | Winston

**核心定位**：
- 消息回调处理（接收托管平台回调）
- AI 智能回复（调用花卷 Agent API）
- 消息发送（通过托管平台 API）

---

## 架构设计

### DDD 分层架构（4大业务域）

```
src/
├── core/                          # 核心基础设施层
│   ├── client-http/              # HTTP 客户端（工厂模式 + Bearer Token）
│   ├── config/                   # 配置管理（环境变量验证）
│   ├── redis/                    # Redis 缓存（全局模块）
│   └── server/response/          # 统一响应处理（拦截器 + 过滤器）
│
├── agent/                         # AI Agent 业务域
│   ├── agent.service.ts          # Agent API 调用层
│   ├── agent-cache.service.ts    # 缓存管理（多层缓存）
│   ├── agent-registry.service.ts # 模型/工具注册表
│   ├── agent-config.service.ts   # 配置档案管理
│   └── context/                  # Agent 上下文配置
│
├── wecom/                         # 企业微信业务域
│   ├── message/                  # 消息处理（核心业务）
│   │   ├── message.service.ts    # 主协调服务（精简版 ~300行）
│   │   ├── services/             # 子服务（关注点分离）
│   │   │   ├── message-deduplication.service.ts  # 去重
│   │   │   ├── message-filter.service.ts         # 过滤
│   │   │   ├── message-history.service.ts        # 历史管理
│   │   │   ├── message-merge.service.ts          # 智能聚合（Bull Queue）
│   │   │   └── message-statistics.service.ts     # 统计监控
│   │   └── utils/
│   │       ├── message-parser.util.ts
│   │       ├── message-sanitizer.util.ts
│   │       └── message-splitter.util.ts          # 消息分段（\n\n + ～）
│   ├── message-sender/           # 消息发送
│   ├── bot/                      # 机器人管理
│   ├── chat/                     # 会话管理
│   ├── contact/                  # 联系人
│   ├── customer/                 # 客户管理
│   ├── room/                     # 群聊
│   └── user/                     # 用户
│
├── sponge/                        # 海绵系统集成（骨架）
│   ├── job/                      # 岗位管理
│   ├── interview/                # 面试管理
│   └── sync/                     # 定时同步
│
└── analytics/                     # 数据分析（骨架）
    ├── metrics/                  # 指标统计
    ├── report/                   # 报表生成
    └── dashboard/                # 仪表盘
```

### 核心业务流程（消息处理）

```
企微消息 → 托管平台回调 /wecom/message
   ↓
MessageController.handleCallback()
   ↓
MessageService.handleMessage()
   ├── 去重检查（MessageDeduplicationService）
   ├── 消息过滤（MessageFilterService）
   ├── 保存历史（MessageHistoryService）
   ├── 智能聚合（MessageMergeService + Bull Queue）
   └── 立即返回 200 OK
   ↓
[异步队列处理]
   ├── 聚合多条消息（1秒窗口 / 最多3条）
   ├── 调用 Agent API（AgentService.chat）
   ├── 消息分段（MessageSplitter）
   └── 发送回复（MessageSenderService + 延迟）
```

---

## 重要 API 文档

### 1. 托管平台 API
- **企业级**：https://s.apifox.cn/34adc635-40ac-4161-8abb-8cd1eea9f445
- **小组级**：https://s.apifox.cn/acec6592-fec1-443b-8563-10c4a10e64c4

关键接口：
- `GET /stream-api/chat/list` - 会话列表
- `GET /stream-api/message/history` - 聊天历史
- `POST /stream-api/message/send` - 发送消息

### 2. 花卷 Agent API
- **官方文档**：https://docs.wolian.cc/

关键接口：
- `POST /api/v1/chat` - 聊天
- `GET /api/v1/models` - 模型列表
- `GET /api/v1/tools` - 工具列表

### 3. NestJS 文档
- https://docs.nestjs.com/

---

## 代码规范（核心）

### TypeScript 严格模式

```typescript
// ❌ 禁止
function process(data: any): any { }

// ✅ 必须
function process(data: ProcessData): Result { }

// ✅ 不确定时用 unknown
function process(data: unknown): string {
  if (typeof data === 'object' && data !== null) {
    return (data as ProcessData).value;
  }
}
```

### NestJS 服务标准结构

```typescript
@Injectable()
export class ExampleService {
  // 1. Logger（必须第一个）
  private readonly logger = new Logger(ExampleService.name);

  // 2. 配置属性
  private readonly apiUrl: string;

  // 3. 构造函数（DI）
  constructor(
    private readonly configService: ConfigService,
    private readonly httpService: HttpService,
  ) {
    this.apiUrl = this.configService.get('API_URL');
  }

  // 4. 公共方法
  async publicMethod(): Promise<Result> {
    try {
      // 业务逻辑
    } catch (error) {
      this.logger.error('Error:', error);
      throw new HttpException('Failed', HttpStatus.INTERNAL_SERVER_ERROR);
    }
  }

  // 5. 私有方法
  private privateHelper(): void { }
}
```

### 统一响应格式（全局自动包装）

**成功**：`{ success: true, data: {...}, timestamp: '...' }`
**失败**：`{ success: false, error: { code, message }, timestamp: '...' }`

```typescript
// ✅ 普通业务接口（自动包装）
@Get('list')
async getList() {
  return await this.service.getList(); // 自动包装
}

// ⚠️ 第三方回调（豁免包装）
@RawResponse()
@Post('callback')
async handleCallback(@Body() body) {
  return { errcode: 0, errmsg: 'ok' }; // 原始格式
}
```

### 命名规范

| 类型 | 规范 | 示例 |
|-----|-----|-----|
| **代码文件** | kebab-case | `agent-api.service.ts`, `message-sender.controller.ts` |
| **文档文件** | kebab-case | `agent-service-architecture.md`, `chat-agent-best-practices.md` |
| **配置文件** | kebab-case | `.cursorrules`, `api-config.service.ts` |
| 类/接口 | PascalCase | `AgentService`, `IAgentProfile` |
| 变量/函数 | camelCase | `sendMessage`, `apiKey` |
| 常量 | UPPER_SNAKE_CASE | `API_TIMEOUT`, `MAX_RETRY_COUNT` |

#### 文件命名详细规则

**✅ 正确示例**：
```
# TypeScript 代码文件
agent.service.ts
message-sender.controller.ts
agent-profile.interface.ts
create-message.dto.ts

# 文档文件
agent-service-architecture.md
message-processing-architecture.md
chat-agent-best-practices.md
product-definition.md

# 配置文件
.cursorrules
api-config.service.ts
```

**❌ 错误示例**：
```
AgentService.ts          # 不要用 PascalCase
agent_service.ts         # 不要用 snake_case
ARCHITECTURE.md          # 不要用全大写
API_CONFIG.md            # 不要用 UPPER_SNAKE_CASE
ChatAgentGuide.md        # 不要用 PascalCase
productDefinition.md     # 不要用 camelCase
```

**命名原则**：
1. **全小写字母**（除 TypeScript、README 等特殊情况）
2. **单词间用连字符 `-` 分隔**
3. **使用描述性名称**，清楚表达文件用途
4. **避免缩写**（除非是广泛认可的，如 api、http、dto）
5. **保持一致性**，项目内统一使用 kebab-case

### 关键禁止项

```typescript
// ❌ 绝对禁止
const apiKey = 'sk-xxx';              // 硬编码密钥
console.log('debug');                 // 使用 console
private service = new Service();      // 手动实例化
function test(data: any): any { }     // 使用 any

// ✅ 必须使用
const apiKey = this.configService.get('API_KEY');
this.logger.log('debug');
constructor(private readonly service: Service) {}
function test(data: Data): Result { }
```

---

## 环境配置（关键变量）

```bash
# Agent API（必须）
AGENT_API_KEY=sk-xxx
AGENT_API_BASE_URL=https://api.wolian.cc
AGENT_DEFAULT_MODEL=claude-sonnet-4-5-20250929
AGENT_TOOLS=web_search,browser

# Redis（必须）
UPSTASH_REDIS_REST_URL=https://xxx.upstash.io
UPSTASH_REDIS_REST_TOKEN=xxx

# 消息处理（可选）
MESSAGE_ENABLE_AI_REPLY=true           # 启用 AI 回复
MESSAGE_ENABLE_SPLIT=true              # 启用分段
MESSAGE_ENABLE_MERGE=true              # 启用聚合
MESSAGE_SEND_DELAY=500                 # 发送延迟（ms）
INITIAL_MERGE_WINDOW_MS=1000           # 聚合窗口（ms）
MAX_MERGED_MESSAGES=3                  # 最大聚合数

# Bull Queue（可选）
REDIS_HOST=localhost
REDIS_PORT=6379
```

---

## 开发工作流

### 添加新功能

1. **确定归属** - core/ | agent/ | wecom/ | sponge/ | analytics/
2. **创建 DTO** - 使用 `class-validator` 验证
3. **实现 Service** - 单一职责，依赖注入
4. **实现 Controller** - Swagger 文档完整
5. **注册 Module** - imports + providers + exports
6. **测试** - 单元测试 + API 测试

### 常用命令

```bash
npm run start:dev    # 开发模式
npm run build        # 构建
npm run format       # 格式化（自动）
npm run lint         # 检查
npm run test         # 测试
```

### Git 提交规范

```bash
git commit -m "feat: 添加消息群发功能"
git commit -m "fix: 修复会话超时问题"
git commit -m "refactor: 重构消息处理逻辑"
git commit -m "docs: 更新 API 文档"
```

---

## 核心设计模式

### 1. 服务拆分（MessageService 案例）

从 1099 行巨石服务 → 5 个子服务（~300 行主服务）
- **去重** - MessageDeduplicationService
- **过滤** - MessageFilterService
- **历史** - MessageHistoryService
- **聚合** - MessageMergeService（队列驱动）
- **统计** - MessageStatisticsService

### 2. 多层缓存

- **内存缓存** - Agent 配置档案
- **Redis 缓存** - Agent 响应、历史记录
- **Bull 队列** - 消息聚合处理

### 3. 工厂模式

```typescript
// HttpClientFactory - 创建带 Bearer Token 的客户端
const client = this.factory.create(token);
const response = await client.post('/api/send', data);
```

### 4. 统一响应处理

- **ResponseInterceptor** - 自动包装成功响应
- **HttpExceptionFilter** - 自动处理异常
- **@RawResponse** - 豁免包装（第三方回调）

---

## 故障排查

### Agent API 连接失败
```bash
# 检查配置
echo $AGENT_API_KEY
curl -H "Authorization: Bearer $AGENT_API_KEY" https://api.wolian.cc/api/v1/models

# 健康检查
curl http://localhost:8080/agent/health
```

### 托管平台调用失败
- 检查 token 有效性
- 查看 API 文档确认参数
- 检查网络连接

### 消息聚合不工作
- 确认 `MESSAGE_ENABLE_MERGE=true`
- 检查 Redis 连接
- 查看 Bull Queue 状态

---

## 最佳实践总结

✅ **务必遵守**：
- 严格类型检查（no `any`）
- 依赖注入（no `new Service()`）
- 使用 Logger（no `console.log`）
- 环境变量配置（no 硬编码）
- 单一职责服务（< 500 行）
- 完整错误处理（try-catch）
- Swagger 文档完整

❌ **绝对禁止**：
- 硬编码敏感信息
- 使用 `console.log`
- 手动实例化服务
- 滥用 `any` 类型
- 不处理异常
- 忽略 TypeScript 错误

---

## 文档编写原则

### 文档类型与长度限制

| 文档类型 | 最大行数 | 推荐行数 | 说明 |
|---------|---------|---------|------|
| **架构文档** | 500 行 | 300-400 行 | 系统/模块架构设计 |
| **API 使用指南** | 600 行 | 300-500 行 | 外部 API 使用说明 |
| **开发规范** | 400 行 | 200-300 行 | 代码规范、最佳实践 |

### 编写原则

✅ **务必遵守**：
- **精简至上** - 只保留核心实现思想和设计决策
- **删除冗余** - 移除详细示例、重复说明、过度解释
- **聚焦关键** - 突出核心算法、关键流程、重要配置
- **避免教程** - 不写 step-by-step 教程，只记录核心模式
- **简化图表** - 使用简洁的文字流程代替复杂图表
- **精简示例** - 每个概念最多 1 个简洁示例
- **目标受众** - 面向已理解业务的开发者，非新手教程

❌ **绝对禁止**：
- 超过推荐行数限制（除非特殊情况）
- 重复解释相同概念
- 冗长的故障排查章节
- 详尽的 FAQ 列表
- 过多的配置示例
- 教程式的分步指南

### 文档结构模板

```markdown
# [文档标题]

## 目录
- 核心章节（4-6个）

## 1. 架构概述
- 简化的架构图（文字即可）
- 文件结构

## 2. 核心组件
- 每个组件的核心职责（3-5条）
- 关键方法签名
- 关键配置参数

## 3. 核心流程
- 简化的流程图（文字即可）
- 关键决策点

## 4. 配置管理
- 必需配置项
- 关键配置示例

## 5. 总结
- 核心要点
- 关键指标

---

**最后更新**: YYYY-MM-DD
```

### 检查清单

在提交文档前检查：
- [ ] 总行数是否在推荐范围内？
- [ ] 每个示例是否必不可少？
- [ ] 是否删除了所有冗余说明？
- [ ] 是否移除了故障排查/FAQ？
- [ ] 是否避免了教程式写法？
- [ ] 目录章节是否精简（不超过 8 个）？

---

**最后更新**：2025-11-04
**维护者**：DuLiDay Team
